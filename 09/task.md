# Задание 1 (4 балла)

Цель этого задания -- используя модуль selectors и async/await синтаксис создать
фреймворк для написания не блокирующих TCP серверов на Python, используя
привычный control flow.

Например, вариант сервера doubler c лекции может выглядеть так:

```
async def doubling_server(port=8080):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setblocking(False)
        s.bind(("", port))
        s.listen(5)
        while True:
            conn, addr = await accept(s)
            await spawn(doubling_connection(conn, addr))


async def doubling_connection(conn, addr):
    print("Connected by", addr)
    with conn:
        while True:
            data = await recv(conn)
            if not data:
                break
            n = int(data.decode())
            res = n * 2
            await send(conn, f"{res}\n".encode())
    print("Disconnected by", addr)
```

По простоте кода, он отличается от варианта с потоками только вызовами `await`,
а по эффективности мало отличается от варианта с ручным вызовом `select`.


**a)** Сердце фреймворка -- планировщик, который определяет, какая корутина
может сделать следующий шаг, и вызывает её. Если корутина по какой-то причине
не может продолжить работу прямо сейчас (например, необходимо прочитать данные
из сокета, которые ещё не пришли), корутина возвращает планировщику описание
события, которое её блокирует. Будем моделировать разные события как пары
`(event, value)`, где `event` -- значение энума `Event`, а `value` -- аргумент,
специфичный для события. Для каждого события мы также определим корутину-генератор, 
которая будет это событие порождать.

Например, событие `Pause` не имеет аргумента (`value` это `None`) и заставляет
текущую корутину приостановить работу до тех пор, пока не отработают все
остальные готовые корутины.

```
from enum import Enum, auto
import types

class Event(Enum):
    Pause = auto()
    
@types.coroutine
def pause():
    yield (Event.Pause, None)    
```

Определите функцию `run` -- планировщик. Функция `run` принимает несколько 
корутин на вход и запускает их в порядке очереди.


```
async def silly(name):
    for _ in range(3):
        print(name, end=' ')
        await pause()
        

def run(*coros):
    ...
    
run(silly("a"), silly("b"), silly("c"))
# Печатает
# a b c a b c a b c  
``` 

**b)** Научим корутины ждать событий от внешнего мира, а именно, данных из сокета.

Определим событие `Accept` с аргументом-сокетом. Событие `Accept` заставляет
корутину ждать момента, когда может быть исполнен метод `.accept` сокета.

``` 
class Event(Enum):
    Pause = auto()
    Accept = auto()

@types.coroutine
def accept(sock):
    yield (Event.Accept, sock)
    (conn, addr) = sock.accept()
    conn.setblocking(False)
    return conn, addr
```

Модифицируйте функцию `run`, чтобы она поддерживала событие `Accept`, 
используя следующий алгоритм:

1. пока существуют корутины, готовые к исполнению
    * исполнить очередную корутину
    * Если результат исполнения -- `Accept`, то убрать корутину из очереди 
      готовых и зарегистрировать соответствующий сокет в селекторе, 
      используя `EVENT_READ` в качестве `events` и саму корутину в качестве 
      `data`
2. вызвать метод `.select()` селектора (это заблокирует текущий поток, пока не 
   наступят какие-то зарегистрированные события)
3. для каждого полученного события
    * добавить соответствующую корутину в очередь готовых
    * убрать регистрацию для сокета, на котором произошло событие
4. если есть готовые корутины, перейти к пункту 1


**c)** Аналогично событию `Accept` и функции `accept`, добавьте

```
@types.coroutine
def send(sock, data):
    ...

@types.coroutine
def recv(sock, bufsize=1024):
    ...
```

Реализованных функций должно хватить, чтобы реализовать сервер `doubling`, 
работающий с одним клиентом:

```
async def doubling_server(port=8080):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setblocking(False)
        s.bind(("", port))
        s.listen(5)
        while True:
            conn, addr = await accept(s)
            await doubling_connection(conn, addr)
            
async def doubling_connection(conn, addr):
    with conn:
        print("Connected by", addr)
        while True:
            data = await recv(conn)
            if not data:
                break
            n = int(data.decode())
            await send(conn, f"{n}\n".encode())
```

Убедитесь, что сервер работает с одним клиентом:

```
def doubling_client(server=("127.0.0.1", 8080)):
    with socket.create_connection(server).makefile(
            mode='rw',
            buffering=1,
            encoding='utf-8',
            newline='\n'
    ) as f:
        while True:
            n = random.randrange(10)
            f.write(f"{n}\n")
            res = f.readline()
            print(n, res)
            time.sleep(random.random() * 2)

if __name__ == "__main__":
    if sys.argv[1] == "server":
        run(doubling_server())
    else:
        assert sys.argv[1] == "client"
        doubling_client()
```

**d)** Как и в случае с использованием потоков, для обработки нескольких клиентов
одновременно необходимо научится запускать дополнительные потоки управления. В 
нашем случае роль потока будет выполнять корутина.

Реализуйте событие и функцию `spawn`, которая позволяет запустить новую
корутину. Корутина-родитель при этом должна продолжать работать. Аргумент
события `Spawn` -- дочерняя корутина. Теперь можно модифицировать 
`doubling_server` для работы с несколькими клиентами:


```
while True:
    conn, addr = await accept(s)
    await spawn(doubling_connection(conn, addr))
```


# Задание 2 (4 балла)

Несмотря на то, что сервер `doubling` работает для простых случаев, он содержит
существенную ошибку. Протокол TCP рассчитан на передачу непрерывного потока
байт, разбиение потока на отдельные сообщения -- задача клиента. В частности,
вызов `.recv` не обязательно прочитает одну строчку: он может вернуть как и
несколько строк, так и только часть одной строки.

**a)** Реализуйте асинхронный генератор `lines`, которая принимает на вход
сокет, и возвращает строки сокета. В качестве разделителя строк используйте
`\n`. Сам разделитель в возвращаемую строчку включать не надо. В качестве
кодировки используйте utf-8. Обратите внимание, что некоторые символы в utf-8 
занимают больше одного байта.


**b)** Симметричная проблема есть и при вызове `send`: нет гарантии, что один 
вызов `send` сможет переслать все данные. Именно поэтому `send` возвращает 
число -- количество реально переданных байт. 

Реализуйте асинхронную функцию `sendall`, которая корректно пересылает весь
переданный массив байт. Обратите внимание, что использовать функцию sendall
сокета не корректно: так как sendall внутри вызывает send, то второй и
последующие вызовы send могут упасть с `BlockingIoError`.

**c)** Используя функции `lines` и `sendall`, исправьте ошибки в функции
`doubling_connection`.


# Thundergram


Thundegram -- новейший протокол для чатов. Протокол текстовый (кодировка --
utf-8) и состоит из последовательности сообщений, разделённых `\n`.

При подключении к серверу, клиент первым сообщением посылает свой логин.
Остальные строчки это сообщения другим пользователям в формате

```
login1,login2,login3: message
```

Сервер просто пересылает клиентам адресованные им сообщения в формате

```
author: message
```

Например, так может выглядеть сессия `Thundergram`:

От клиента к серверу:

```
bob
alice,robert: Hi, this is bob.
alice: how are you?
```

От сервера к клиенту:

```
alice: Hello from Alice.
robert: Hi! 
alice: I am fine!
```

# Задание 3 (4 балла)

**a)** Для реализации протокола Thundergram необходимо писать и читать из сокета 
одновременно. Однако метод `register` не позволяет зарегистрировать один сокет
больше одного раза:

```
sel = selectors.DefaultSelector()
sel.register(sock, EVENT_READ, reader_co)
sel.register(sock, EVENT_WRITE, writer_co)  # RuntimeError 
```

Добавьте в планировщик возможность регистрировать разные корутины на события
чтения и записи в один сокет. Для этого, используйте в методе `register` пару
`(reader_co, writer_co)` в качестве `data`. Чтобы поддержать добавление подписки
на один тип события когда подписка на второй тип события уже существует, вам
понадобятся функции селектора `get_map` и `modify`. Чтобы проверить, какое из
зарегистрированных событий сработало, следует посмотреть на `mask`:

```
for event, mask in sel.select():
    if mask & EVENT_READ:
        # handle read
    if mask & EVENT_WRITE:
        # handle write
```


**b)** Обратите внимание на то, что подписать две разные корутины на одно и то
же событие на одном сокете нельзя. Это естественное ограничение: если одна
корутина попытается записать в сокет "hello", а другая в это же время --
"world", то результат может быть произвольный. В связи с этим, в нашем сервере
для Thundergram будет созданно две корутины на каждого клиента: одна корутина 
будет читать сообщения из клиентского сокета, другая будет записывать в него
сообщения от других клинетов. При этом понадобится как-то передавать сообщения
от корутин-читателей к корутинам-писателям. Для этого мы воспользуемся каналом.

Реализуйте класс `Channel` и события `ChanSend` и `ChanRecv` со следующими
полями:

```
class Channel:
    def __init__(self):
        self._sender = self._receiver = None
```


Обработка `ChanSend` и `ChanRecv` должна работать следующим образом:
  
  * сохранить текущую корутину в поле `_sender` или `_receiver` канала
  * если оба поля -- не `None`, то добавить обе корутины в очередь готовых 
    к исполнению, и очистить канал.

Реализуйте асинхронные методы `send(self)` и `recv(self)` для класса `Channel`,
генерирующие события `ChanSend` и `ChanRecv`. Аргумент этих событий -- сам
канал. Хотя интерфейс канала пока не позволяет пересылать сообщения, его уже
можно использовать для синхронизации:

```
async def ping(chan):
    print("ping")
    await chan.send()
    
asyn:c def pong(chan)
    await chan.recv()
    print("pong")

chan = Channel()
run(ping(chan), pong(chan))
run(pong(chan), ping(chan))
```

В каком бы порядке мы не запускали корутины, ping всегда будет напечатано раньше
pong.

**c)** Добавим в канал возможность пересылки сообщений. Для этого добавим новое 
поле, `_value` и параметр `value` в метод `send`. Измените функции `send` и
`recv` так, чтобы `send` устанавливал поле `_value`, а `recv` его возвращал.


# Задание 4 (4 балла)

Всё готово для реализации сервера Thundergram! 

Аналогично `doubler`, сервер буде состоять из двух функций:

```
async def thundergram_server(port=8080):
    ...

async def thundergram_connecton(peers, conn, addr):
    pass
```
  
  
**a)** Реализуйте `thundergram_server` аналогично `doubling_server`. Чтобы 
пересылать сообщения между клиентами, сервер должен поддерживать словарь `peers`,
где ключи -- логины пользователей а значения -- каналы. 

**b)** Реализуйте функцию `thundergram_connecton`, выполняющую протокол 
thundegram по следующему алгоритму:

* считать из первой строки `conn` логин пользователя. Вам может понадобится 
  функция `anext`, асинхронный аналог функции `next`. Пока такой функции в Python
  нет, так что можно позвать `__anext__` напрямую.
* создать новый канал и занести его в массив `peers`
* запустить новую корутину, которая будет в цикле читать сообщения из
  канала и записывать их в `conn` в формате `login: message`
* для каждой последующей строчки:
    - разбить её на список адресатов и сообщение
    - послать сообщение в канал каждого существующего адресата
    
    
Сервер Thundergram готов! Его можно протестовать при помощи следующего простого
клиента:

```
def thundergram_client():
    def reader(f):
        for line in sys.stdin:
            f.write(line.strip() + '\n')
            f.flush()

    with socket.create_connection(("127.0.0.1", 8080)) as conn:
        with conn.makefile(buffering=1, newline='\n', mode='rw') as f:
            thread = threading.Thread(target=reader, args=(f,))
            thread.start()

            for line in f:
                print(line)
``` 


# Задание 5, инженерное счастье (4 балла)


**a)** Можно заметить, что к концу домашнего задания в функции `run` скопилось 
очень много кода. В основном этот код управляет двумя сущностями -- очередью 
корутин и селектором. Реализацию `run` можно сделать проще для понимания, если
вынести большую часть кода в класс `EventLoop` с методом `run` и набором 
вспомогательных методов. Реализуйте класс `EventLoop`. 