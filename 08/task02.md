# Spyke

Команда хакеров под названием λ-лама сумела внедрить свой шпионский сервер в
дата-центр одной из крупных социальных сетей. Кодовое имя сервера-шпиона Spyke.
Сервер способен перехватывать HTTP пакеты во внутренней сети дата-центра и
пересылать их агентам для анализа. Ваша задача: реализовать агента, способного
анализировать поток HTTP пакетов с целью сбора статистики по пользователям
социальной сети.

# Задание 3 (4 балла)

Spyke общается с агентами сообщениями по протоколу TCP. Каждое сообщение -- это
последовательность строк в кодировке ASCII, разделённых символами `"\r\n"`.
Сообщения отделяются друг от друга последовательностью "\r\n\r\n"`.

**a)** Давайте реализуем менеджер контекста `connection`, который создаёт
соединение с сервером и преобразует его в объект, похожий на файл.

Для кросс-платформенной работы с сокетам в Python есть модуль
  `socket`. Нам потребуются:

  * функция `socket.create_connection`, создающая TCP-соединение,
  * метод сокета `sendall`, который принимает последовательность
    байт и отправляет её в сокет, и
  * метод сокета `makefile`, который преобразует открытый сокет в
    объект, похожий на файл.

```
import socket
from contextlib import contextmanager

@contextmanager
def connection(host, port, *, mode="r"):
    with socket.create_connection((host, port)) as sock:
        with sock.makefile(mode, buffering=1,
                           encoding="ascii",
                           newline="\r\n") as conn:
            yield conn
```

Аргумент `buffering=1` включает построчную буферизацию для данных, проходящих
через сокет, а аргумент `newline="\r\n"` сообщает Python, что строки
заканчиваются на `"\r\n"`.

**b)** Прежде, чем получать HTTP пакеты, агент должен зарегистрироваться. Для
регистрации достаточно подключиться к серверу `spyke.compscicenter.ru:7182` и
прочитать ответ сервера. Формат ответа следующий:

```
<token>\r\n
<host1>:<port1>\r\n
<host2>:<port2>\r\n
...
```

Реализуйте функцию `handshake`, которая принимает два аргумента: `host` и `port`
и возвращает пару `(token, servers)`, где `servers` -- это список серверов вида

```
[(host1, int(port1)), (host2, int(port2)), ...]
```

  Пример использования функции `handshake`:

```
>>> host, port = "spyke.compscicenter.ru", 7182
>>> token, servers = handshake(host, port)
>>> token
'WGOKVF'
>>> servers
[('spyke.compscicenter.ru', 7183),
 ('spyke.compscicenter.ru', 7184),
 ('spyke.compscicenter.ru', 7185)]
```

**c)** После получения списка серверов агент должен подключиться к каждому из
серверов, отправить ему токен и начать принимать HTTP пакеты.

Модифицируйте менеджер контекста `connection` так, чтобы он принимал
опциональный аргумент `token` и, прежде чем преобразовать сокет в файл,
отправлял токен серверу. Для отправки токена следует использовать метод
`sendall`.

```
@contextmanager
def connection(host, port, token=None, *, mode="r"):
    # ...
```

Не забудьте, что Spyke ожидает, что все строки заканчиваются на `"\r\n"`,
поэтому вам нужно отправить `"{token}\r\n"`.

**d)** Реализуйте функцию `follow`, которая возвращает генератор, читающий
сообщения от сервера. Функция должна принимать три аргумента: `host`, `port` и
`token`. Алгоритм работы:

1. открыть соединение с сервером,
2. читать строки, обрезая `"\r\n"` на конце до тех пор, пока не встретится
   строка, состоящая только из символов `"\r\n"`,
3. вернуть накопленные строки из генератора и перейти к пункту 2.

Если в какой-либо момент работы генератора возникнет исключение, необходимо
перезапустить генератор, начиная с пункта 1. Все возможные при работе с
сокетами исключения наследуются от класса `OSError`.

```
>>> host, port = "spyke.compscicenter.ru", 7182
>>> token, ((server_host, server_port), *_) = handshake(host, port)
>>> follower = follow(server_host, server_port, token)
>>> list(next(follower))
['GET /id4034673 HTTP/1.1', 'Host: vk.infty.ru', 'Date: Tue, 27 Oct 2015 21:02:11 GMT',
 'From: ul@yandex.ru']
```

# Задание 4  (4 балла)

Сопрограмма -- это вывернутый наизнанку генератор: генератор порождает значения,
в то время как сопрограмма их принимает. Убийственной особенностью сопрограмм
является то, что их можно комбинировать для построения сложных схем обработки
данных. Попробуем убедиться в этом.

**a)** Реализуйте декоратор `coroutine`, который принимает функцию-генератор и
возвращает новую функцию, инициализирующую генератор сразу после создания.
  
```
>>> @coroutine
... def printer():
...     while True:
...         print((yield))
...
>>> p = printer()
>>> p.send("Hello, world!")
Hello, world!
```

Все сопрограммы можно условно разделить на *начальные*, промежуточные* и
конечные*. Начальные и промежуточные сопрограммы принимают обязательный аргумент
`target` -- сопрограмму, которой нужно передать результат, вычисленный текущей
сопрограммой. В отличие от начальных сопрограмм промежуточные и конечные
сопрограммы требуют вход для вычисления результата. `identity` -- промежуточная
сопрограмма, `printer` -- конечная. Пример начальной сопрограммы встретится нам
далее.

```
>>> @coroutine
... def identity(target):
...     while True:
...         item = yield
...         target.send(item)
...
>>> g = identity(printer())
>>> g.send("Hello, world!")
Hello, world!
```

Соединение между `identity` и `printer` можно схематично изобразить в виде
диаграммы `identity -> printer`.

**b)** Реализуйте начальную сопрограмму `round_robin`, которая принимает список
итераторов `sources` и последовательно отправляет в `target` по одному элементу
из каждого итератора. Если у какого-либо из итераторов заканчиваются элементы,
`round_robin` исключает его из списка и продолжает работать с оставшимися
итераторами.

Пример:

```
>>> round_robin([iter("ab"), iter("XYZ")], printer())
a
X
b
Y
Z
```

**c)** Объявите класс `HTTPRequest` с неизменяемыми полями:

* `method`, например, `"GET"`,
* `resource`, например, `"/"`,
* `protocol`, например, `"HTTP/1.1"`,
* `headers` -- словарь заголовков HTTP запроса.

**d)** Реализуйте промежуточную сопрограмму `parse_http`, которая принимает
сообщения сервера и отправляет в `target` экземпляры класса `HTTPRequest`.

HTTP запрос состоит из одной или более строк. Первая строка содержит метод,
ресурс и используемую версию протокола HTTP, например:

```
GET /friends HTTP/1.1\r\n
```

Последующие строки содержат заголовки HTTP запроса в виде ключ: значение.

```
Date: Wed, 11 Feb 2009 11:20:59 GMT\r\n
From: ivan.petrov@mail.ru\r\n
```

Обратите внимание, что до и после `:` может быть произвольное количество
пробелов.

Заголовки нужно собрать в словарь, приведя их имена к нижнему регистру. Для
запроса из примера выше:

```
>>> request.headers
{'from': 'ivan.petrov@mail.ru', 'date': 'Wed, 11 Feb 2009 11:20:59 GMT'}
```

Протестировать получившуюся цепочку сопрограмм можно так:

```
host, port = "spyke.compscicenter.ru", 7182
token, servers = handshake(host, port)
round_robin([
   follow(host, port, token) for host, port in servers
], parse_http(printer()))
```

# Задание 5 (4 балла)

Часть агента, отвечающая за получение HTTP запросов от сервера, готова -- время
за *анализаторами*. Анализатором будем называть промежуточную сопрограмму,
которая считает специфичную для отправителя запроса статистику по входному
потоку HTTP запросов. Агент должен поддерживать следующие анализаторы:

* `number_of_requests`,
* `number_of_bytes`,
* `ip_addresses`,
* `popular_resources`.

**a)** Реализуйте промежуточную сопрограмму `per_user`, которая принимает два
аргумента: целое число `wait` и функцию `target_factory`.

Сопрограмма должна работать в соответствии со следующим алгоритмом:

1. сгенерировать специальное значение `flush = object()`,
2. `wait` раз повторить:
    - получить запрос,
    - записать в переменную `user` -- email адрес пользователя
      из заголовка `"from"`. Если такого заколовка нет, то нужно использовать
      специальное значение `"<unknown>"` в качестве адреса.
    - записать в переменную `target` сопрограмму для
      пользователя `user`: если сопрограмма для этого пользователя
      ещё не создана, создать её с помощью `target_factory(user, flush)`,
    - отправить в `target` полученный запрос;
3. отправить в каждую созданную сопрограмму специальное значение `flush`,
4. перейти к пункту 2.

Таким образом, сопрограмма `per_user` реализует логику распределения запросов по
анализаторам для каждого пользователя.

**b)** Реализуйте анализатор `number_of_requests`, который принимает три
аргумента: `user` -- email пользователя или `"<unknown>"`, `flush` -- сигнал
окончания цикла сбора статистики и `target`.

Анализатор `number_of_requests` должен считать количество запросов, которое
пришло за цикл сбора статистики. Идентификатор анализатора: `"requests"`.

Базовая структура всех анализаторов выглядит следующим образом:

```
def useful_analyzer(user, flush, target):
    while True:
        request = yield
        if request is flush:
            target.send(("useful", user, something_useful))
            # подготовиться к новому циклу: сбросить все
            # счётчики, очистить все структуры данных и.т.п.
        else:
            # обработать новый запрос из потока
```

Анализатор **всегда** должен отправлять в `target` кортеж, состоящий из
идентификатора анализатора, значения аргумента `user` и посчитанной статистики.
Если статистика -- это iterable* объект, то нужно отдельно отправить каждый её
элемент, то есть:
  
```
for item in something_useful:
    target.send(("useful", user, item))
```

**с)** Реализуйте анализатор `number_of_bytes`, который считает количество
байтов, отправленных пользователем. Получить размер тела запроса в байтах можно
из заголовка `"content-length"`. Если у запроса отсутствует этот заголовок, то
можно считать, что тело запроса пустое. Идентификатор анализатора: `"bytes"`.

**d)** Реализуйте анализатор `popular_resources`, который поддерживает пять
наиболее часто посещаемых пользователем URL адресов. Чтобы построить URL адрес,
необходимо сконкатенировать значение заголовка `"host"` и атрибута
`request.resource`:

```
>>> request.headers["host"]
'example.com'
>>> request.resource
'/index.html'
>>> request.headers["host"] + request.resource
example.com/index.html
```

Идентификатор анализатора: `"resources"`.

**e)** Реализуйте анализатор `ip_addresses`, который поддерживает множество IP
адресов, с которых пользователь совершает запросы. Идентификатор анализатора:
`"ipaddr"`.

IP адрес можно получить только для запросов, прошедших через прокси-сервер, так
как в этом случае к заголовкам запроса добавляется специальный заголовок
`"x-forwarded-for"`. Структура заголовка следующая: `client_ip, proxy_ip1,
proxy_ip2, ...`. Таким образом, чтобы получить IP адрес, достаточно взять первый
элемент из списка адресов, разделённых запятой.

Если у запроса отсутствует заголовок `"x-forwarded-for"`, его нужно
игнорировать.

# Задание 6 (4 балла)

Наш агент почти готов -- дело за малым!

**a)** Реализуйте промежуточную сопрограмму `broadcast`, которая принимает
список сопрограмм `targets`. После получения очередного элемента `broadcast`
отправляет его всем сопрограммам из списка.
  
```
>>> p = broadcast([printer(), printer()])
>>> p.send("Hello, world!")
Hello, world!
Hello, world!
```

**b)** Реализуйте конечную сопрограмму `report`, которая принимает три
аргумента: `host`, `port` и `token`. Сопрограмма должна соединяться с сервером
и отправлять ему результаты работы анализаторов в следующем формате: 

```
f"{id}: {user} {statistic}\r\n"
```

Поведение сопрограммы в случае исключения должно быть аналогично `follow`.
Результаты работы анализаторов между переподключениями сохранять не нужно.

Обратите внимание, что менеджер контекста `connect` принимает опциональный
аргумент `mode="r"`. При реализации `report` нужно будет использовать значение,
соответствующее открытию файла для записи.

**с)** Соберём агента.

```
from functools import partial

if __name__ == "__main__":
    host, port = "spyke.compscicenter.ru", 7182
    token, servers = handshake(host, port)
    wait = 4096

    r = report(host, port, token)
    analyzer = broadcast([
        per_user(wait, partial(number_of_requests, target=r)),
        per_user(wait, partial(number_of_bytes, target=r)),
        per_user(wait, partial(popular_resources, target=r)),
        per_user(wait, partial(ip_addresses, target=r)),
    ])
    round_robin([
        follow(host, port, token) for host, port in servers
    ], parse_http(analyzer))
```

Схему работы собранного нами агента можно представить в виде диаграммы:

![kernel-pipeline](https://i.imgur.com/iNGftip.jpg)
