# Задание 1 (4 балла)

В следующих заданиях необходимо переписать имеющуюся реализацию в терминах
выражений-генераторов и функций из модуля `itertools`.
  
**a)** Функция `ilen` возвращает количество элементов в переданном итераторе.

```
def ilen(iterable):
    acc = 0
    for item in iterable:
        acc += 1
    return acc
```

**b)** Функция `find` принимает итератор и предикат и возвращает первый элемент
итератора, удовлетворяющий предикату. Если такого элемента нет, функция
поднимает `ValueError`.
  
```
def find(iterable, p):
    for item in iterable:
        if p(item):
            return item
    else:
        raise ValueError("not found")
```

**c)** Генератор `chunked` разбивает переданный итератор на непересекающиеся
блоки размера `n`. Обратите внимание, что последний блок может содержать меньше
чем `n` элементов.

```
def chunked(iterable, n):
    acc = []
    for item in iterable:
        if len(acc) == n:
            yield iter(acc[:])
            acc.clear()
        acc.append(item)

    if acc:
        yield iter(acc)
```

**d)** Генератор `rle` применяет кодирование повторов (run-length encoding) к
элементам переданного итератора. Суть кодирования повторов в замене
повторяющихся элементов на пары `(item, count)`, где `count` -- количество раз,
которое элемент встретился подряд.
  
```
def rle(iterable):
    current = None
    count = 0
    for item in iterable:
        if not count or item == current:
            count += 1
        else:
            yield current, count
            count = 1

        current = item

    if count:
        yield current, count
```

# Задание 2 (4 балла)

В следующих заданиях не обязательно, но можно пользоваться функциями из модуля
`tertools`.

**a)** Реализуйте генератор `intersperse`, который принимает объект-разделитель
и итератор и возвращает новый итератор, в котором между каждыми двумя
элементами из входного итератора находится объект-разделитель.
  
```
>>> list(intersperse(-42, range(3)))
[0, -42, 1, -42, 2]
>>> it = intersperse(-42, itertools.count())
>>> next(it)
0
>>> next(it)
-42
```

Здесь и далее под итератором подразумевается объект класса, реализующего как
минимум, метод `__iter__` протокола итераторов. Не забудьте при необходимости
вызывать функцию `iter`:

```
it = iter(iterable)
```

**b)** Напишите класс-итератор `peekable`, который принимает итератор и
реализует метод `peek`, позволяющий посмотреть на следующий элемент без
изменения состояния итератора.
  
```
>>> it = peekable([1, 2, 3])
>>> it.peek()
1
>>> it.peek()
1
>>> next(it)
1
>>> it.peek()
2
```

Если итератор пуст, функция `peek` должна поднимать исключение `StopIteration`.

**c)** Реализуйте функцию `padded`, которая принимает итератор, значение по
умолчанию и целое неотрицательное число `n` и возвращает новый итератор, длины
`n`. Если исходный итератор содержал менее `n` элементов, то к нему
добавляется значение по умолчанию соответствующее количество раз.

```
>>> list(padded(range(3), -42, 5))
[0, 1, 2, -42, -42]
>>> list(padded(range(3), -42, 1))
[0]
```

**d)** Реализуйте функцию `sliding`, которая принимает итератор и два целых
неотрицательных числа: размер блока `n` и шаг `step`. Результатом функции
является новый итератор, перечисляющий блоки размера `n` из элементов
исходного. Любые два соседних блока пересекаются на `n - step` элементов.
  
```
>>> list(map(list, sliding(range(10), 3, 2)))
[[0, 1, 2], [2, 3, 4], [4, 5, 6], [6, 7, 8]]
```
