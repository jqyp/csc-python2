# Задание 1, λ-fu (4 балла)

Для решения следующих задач можно, но не обязательно, воспользоватся
анонимными функциями (лямбдами).

**a)** Напишите функцию `compose`, которая строит
  композицию двух переданных ей функций.

```
>>> f = compose(lambda x: x**2, lambda x: x + 1)
>>> f(2)
9
```

**b)** Напишите функцию `const`, которая по заданному значению
строит константную функцию, то есть функцию, возвращающую одно и то же
значение вне зависимости от аргументов.

```
>>> f = const(42)
>>> f()
42
>>> f(range(4), range(2), foo="bar")
42
```

**c)** Напишите функцию `flip`, которая принимает функцию `f`.
Результатом её работы является функция, применяющая `f` к
позиционным аргументам в обратном порядке. Ключевые аргументы
передаются без изменений.

```
>>> f = flip(map)
>>> list(f(range(5), range(0, 10, 2), lambda x, y: x**y))
[1, 2, 16, 216, 4096]
>>> list(map(lambda x, y: x**y, range(0, 10, 2), range(5)))
[1, 2, 16, 216, 4096]
```

**d)** Напишите функцию 'curry', которая принимает функцию `f`. `curry` должна
возвращать новую функцию, у которой часть аргументов зафиксирована. Эти
аргументы также должны быть переданы в функцию `curry`.

```
>>> def pow(x, p):
...     return x**p
...
>>> ten_pow = curry(pow, 10)
>>> ten_pow(3)
1000
>>> square = curry(pow, p=2)
>>> square(42)
1764
```

# Задание 2 (4 балла)

Следующие задания нужно реализовать либо с помощью `map`, `filter` и `zip`, либо
с помощью генераторов списков. Использовать `yield`, модуль `itertools` и
встроенные функции `enumerate`, `all` и `any` нельзя.

**a)** Напишите функцию `enumerate`, которая перенумеровывает элементы
*переданной последовательности, начиная со `start`, если он есть, иначе с нуля.
  
```
>>> list(enumerate("abcd"))
[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]
>>> list(enumerate(map(lambda ch: ch * 2, "abcd"), 1))
[(1, 'aa'), (2, 'bb'), (3, 'cc'), (4, 'dd')]
```

**b)** Напишите функцию `which`, которая принимает предикат и последовательность
*и возвращает индексы элементов последовательности, удовлетворяющих предикату.

```
>>> list(which(lambda x: x % 2 == 0, [4, 9, 15]))
[0]
```

**c)** Напишите функцию `all`, которая принимает предикат и последовательность и
*проверяет, что все элементы последовательности удовлетворяют предикату.

```
>>> all(lambda x: x % 2 == 0, [4, 9, 15])
False
>>> xs = [1, 1, 2, 3, 4, 8]
>>> all(lambda p: p[0] <= p[1], zip(xs, xs[1:]))
True
```

**d)** Дополните функцию `all` функцией `any`, которая проверяет, что в
последовательности встречается хотя бы один элемент, удовлетворяющий предикату.

```
>>> any(lambda x: x % 2 == 0, [4, 9, 15])
True
>>> any(lambda x: x % 2 == 0, [])
False
```

# Парсер-комбинаторы и S-выражения

Парсером называется часть программы, которая преобразует последовательность
простых объектов в более сложную структуру, неявно содержащуюся во входной
последовательности, например, преобразует исходный код в абстрактное
синтаксическое дерево.

Парсер-комбинаторы --- популярная техника создания парсеров, суть которой
заключается в построении парсеров путём комбинирования других парсеров.

Мы будем представлять парсер как функцию, принимающую на вход строку и
возвращающую тройку вида `(tag, result, leftover)`, где

    * `tag` -- `OK`, если парсер принял переданную ему строку, или `ERROR`, 
      если произошла ошибка;
    * `result`  содержит результат работы парсера или текст собщения об ошибке;
    * `leftover` -- это входная строка без изменений, если произошла ошибка, или 
      часть строки, не использованная парсером, если ошибки не было.

В качестве примера рассмотрим реализацию парсера `dot`, который
ожидает, что первым символом входной строки будет `"."`.

```
# Глобальные константы для tag.
OK, ERROR = "OK", "ERROR"


def dot(input):
    if not input:
        return ERROR, "eof", input
    if input[0] != ".":
        return ERROR, f"expected . got `{input[0]}`", input
    return OK, ".", input[1:]
```

Попробуем парсер `dot` в деле:
```
>>> dot("...")
('OK', '.', '..')
>>> dot("!..")
('ERROR', 'expected . got `!`', '!..')
>>> dot("")
('ERROR', 'eof', '')
```

В этом задании мы реализуем классический вариант парсер-кобинаторов и применим
его для разбора арифметических S-выражений.

S-выражения (*англ.* symbolic expressions) представляют из себя выражения
вида

```
(op arg1 arg2 ...)
```

где `op` --- символ операции, например, `+` или `*`, а `arg1 arg2 ...` --
последовательность аргументов, которые могут быть числами или другими
S-выражениями.

Пример S-выражения для $42 + 2 * 4$:
```
(+ 42 (* 2 4))
```

# Задание 3 (4 балла)

**a)** Обобщим логику парсера `dot`, реализовав парсер-комбинатор `char`,
который принимает символ и возвращает парсер, ожидающий указанный символ в
начале входной строки.

```
def char(ch):
    def inner(input):
        if not input:
            return ERROR, "eof", input
        if input[0] != ch:
            return ERROR, f"expected {ch} got `{input[0]}`", input
        return OK, ch, input[1:]
    return inner
```

Посмотрим, что получилось:

```
>>> p = char("(")
>>> p("()")
('OK', '(', ')')
```

Реализацию `char` можно также обобщить на случай произвольного числа символов.
Напишите парсер-комбинатор `any_of`, который принимает произвольное количество
символов в виде строки и возвращает парсер, ожидающий любой из указанных
символов в начале входной строки.

```
>>> p = any_of("()")
>>> p("(")
('OK', '(', '')
>>> p(")")
('OK', ')', '')
>>> p("[]")
('ERROR', 'expected any of () got `[`', '[]')
```

**b)** Реализуйте комбинатор `chain`. Он принимает на вход произвольное
количество других парсеров и возвращает новый парсер, котрый работает так:
    
    * последовательно применяет переданные парсеры;
    * если какой-то парсер вернул ошибку, то и результат `chain` -- ошибка;
    * иначе результат `chain` это список результатов парсеров.

```
>>> p = chain(char("("), char(")"))
>>> p("()")
('OK', ['(', ')'], '')
>>> p("(")
('ERROR', 'eof', '(')
```

**c)** Следующий полезный комбинатор называется `choice`. Он принимает
произвольное количество других парсеров и возвращает новый парсер, который
пытется примениять каждый парсер к исходному входу и возвращает результат, как
только один из них принял вход, то есть вернул `tag == OK`. Если не один из
парсеров не принял входную строку, то результат это ошибка.

```
>>> p = choice(char("."), char("!"))
>>> p(".")
('OK', '.', '')
>>> p("!")
('OK', '!', '')
>>> p("?")
('ERROR', 'none matched', '?')
```

**d)** Реализуйте комбинатор `many`, который принимает парсер и возвращает новый
парсер, применяющий переданный пока это возможно: ноль или более раз.

```
>>> p = many(char("."))
>>> p("...?!")
('OK', ['.', '.', '.'], '?!')
>>> p(".")
('OK', ['.'], '')
>>> p("I have no idea what this is.")
('OK', [], 'I have no idea what this is.')
```

**e)** Реализуйте комбинатор `many1`, который принимает парсер и возвращает новый
парсер, применяющий переданный пока это возможно: один или более раз.

```
>>> p = many1(char("."))
>>> p(".!")
('OK', ['.'], '!')
>>> p("!!")
('ERROR', 'expected . got `!`', '!!')
>>> p("")
('ERROR', 'eof', '')
```

# Задание 4 (4 балла)

**a)**

Выразите в терминах реализованных парсер-комбинаторов комбинатор `sep_by`.
Комбинатор принимает два парсера: `p` и `separator` -- и возвращает новый
парсер. Этот парсер применяет ко входной строке парсер `p`, затем, если не было
ошибки, парсеры `separator` и `p` и так далее. Обратите внимание, что
последовательность парсеров всегда заканчивается на `p`.

```
>>> p = sep_by(any_of("1234567890"), char(","))
>>> p("1,2,3")
('OK', ['1', '2', '3'], '')
>>> p("1")
('OK', ['1'], '')
>>> p("")
('ERROR', 'eof', '')
```

Вам может быть полезна функция `transform`, преобразующая результат работы
парсера, если он принял входную строку:
  
```
def transform(p, f):
    def inner(input):
        tag, res, leftover = p(input)
        return tag, f(res) if tag == OK else res, leftover
    return inner
```

**b)** Реализуйте функцию `parse`, которая принимает парсер и строку, и, если
парсер принял **весь** вход, возвращает результат работы парсера, иначе падает
с ошибкой.


```
>>> p = sep_by(any_of("1234567890"), char(","))
>>> parse(p, "1,2,3")
['1', '2', '3']
>>> parse(p, "...")
Traceback (most recent call last):
  # ...
AssertionError: ('expected any of 1234567890 got .', '...')
>>> parse(p, "1!")
Traceback (most recent call last):
  # ...
AssertionError: (['1'], '!')
#                ^ res,  ^ leftover
```

Вам будет полезен оператор `assert`, который принимает условие и произвольное
выражение и поднимает `AssertionError`, если условие -- falsy значение:
  
```
>>> assert g.is_connected(), ("graph is disconnected", g)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError: ('graph is disconnected', [...])
```

Всё готово для того, чтобы построить парсер арифметических S-выражений. Сделаем
это:

```
lparen, rparen = char("("), char(")")
ws = many1(any_of(" \r\n\t"))
number = transform(
    many1(any_of("1234567890")),
    lambda digits: int("".join(digits))
)
op = any_of("+-*/")


def sexp(input):
    args = sep_by(choice(number, sexp), ws)

    # Уберём лишние None из результата chain.
    p = chain(lparen, op, ws, args, rparen)
    p = transform(p, lambda res: (res[1], res[3]))
    return p(input)
```

Проверим, что всё работает:

```
>>> parse(sexp, "(+ 42 (* 2 4))")
('+', [42, ('*', [2, 4])])
```

**c)** Это задание необязательно для выполнения и не оценивается баллами. Вы
можете реализовать его исключительно для своего удовольствия.

Реализуйте функцию `eval_sexp`, которая принимает результат разбора S-выражения
и вычисляет его результат.
```
>>> eval_sexp(parse(sexp, "(+ 42 (* 2 4))"))
50
```
