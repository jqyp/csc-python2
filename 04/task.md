# Задание 1 (4 балла)

В следующих заданиях необходимо использовать методы класса `str`, описанные в
лекции.

**a)** Напишите функцию `capwords`, которая принимает строку и опциональный
разделитель и возвращает новую строку, в которой каждое слово начинается с
заглавной буквы. Логика работы функции `capwords` должна быть аналогична методу
`str.split`.
  
```
>>> capwords("foo,bar boo,", sep=",")
'Foo,Bar boo,'
>>> capwords(" foo  \nbar\n")
'Foo Bar'
>>> capwords("foo,bar boo,", sep="")
Traceback (most recent call last):
  ...
ValueError: empty separator
```

**b)** Напишите функцию `cut_suffix`, которая принимает строку и суффикс.
Функция должна вернуть эту строку, но без заданного суффикса.

```
>>> cut_suffix("foobar", "bar")
'foo'
>>> cut_suffix("foobar", "boo")
'foobar'
```

**c)** Напишите функцию `boxed`, которая принимает строку и два аргумента:
символ `fill` и число `pad`. Результатом работы функции `boxed` должна стать
исходная строка, обрамлённая символами `fill`, как это показано в примере.

```
>>> print(boxed("Hello world", fill="*", pad=2))
*****************
** Hello world **
*****************
>>> print(boxed("Fishy", fill="#", pad=1))
#########
# Fishy #
#########
```

**d)** Напишите функцию `find_all`, которая возвращает список индексов всех 
вхождений подстроки в строке.

```
>>> find_all("abracadabra", "a")
[0, 3, 5, 7, 10]
>>> find_all("arara", "ara")
[0, 2]
```

**e)** Напишите функцию `common_prefix`, которая возвращает наибольший общий
префикс двух или более строк.
  
```
>>> common_prefix("abra", "abracadabra", "abrasive")
"abra"
>>> common_prefix("abra", "foobar")
""
```

# Задание 2 (4 балла)

В следующих заданиях стоит использовать методы файловых объектов, описанные в
лекции.

**a)** Напишите функцию `reader`, которая принимает путь к файлу и возвращает
файловый объект. Функция должна работать с архивированными файлами, сжатыми с
помощью `gzip` и `bzip2`. Несколько примеров:

```
>>> reader("./example.txt")
<_io.TextIOWrapper name='./example.txt' mode='rt' encoding='UTF-8'>
>>> reader("./example.txt.gz", mode="rt", encoding="ascii")
<_io.TextIOWrapper name='./example.txt.gz' encoding='ascii'>
>>> reader("./example.txt.bz2", mode="wb")
<bz2.BZ2File object at 0x1066e6978>
```

Можно считать, что файл, оканчивающийся на `.gz`, всегда является `gzip`
архивом, аналогично для `bz2` и `bzip2`. Для реализации вам потребуются функции
`open` из соответствующих модулей стандартной библиотеки:

```
>>> import gzip
>>> gzip.open
<function open at 0x1066dc730>
>>> import bz2
>>> bz2.open
<function open at 0x1066fde18>
```

**b)** [She-bang](http://en.wikipedia.org/wiki/Shebang_(Unix)) -- последовательность
`#!`, которая используется Unix-подобными системами для запуска исполняемых
скриптов. She-bang *всегда* пишется в самом начале файла. После she-bang следует
опциональный пробел и путь к программе-интерпретатору, например:

```
#! /bin/sh
```

```
#!/usr/bin/env python3 -v
```
  
Напишите функцию `parse_shebang`, которая принимает путь к исполняемому скрипту
и возвращает путь к программе-интерпретатору, если скрипт содержит she-bang, и
`None` в обратном случае.

```
>>> parse_shebang("./script.sh")
"/bin/sh"
```

```
>>> parse_shebang("./script.py")
"/usr/bin/env python3 -v"
```

# Задание 3, Py-Hop (8 баллов)

Вероятностная модель языка описывает фрагменты текста на некотором языке в
терминах случайных процессов. Одна из самых простых моделей языка формулируется
следующим образом. Предположим, что нам известно множество всех слов в языке.
Будем порождать слова в предложении слева направо одно за другим: 
  - Случайно выберем первые два слова из множества слов. 
  - Каждое t-е слово будем порождать при условии известных нам (t-1)-го и 
    (t-2)-го слов.

Попробуем построить модель языка по лирике известного хип-хоп исполнителя Снуп
Догга.

**a)** Напишите функцию `words`, которая принимает текстовый файл и возвращает
список слов из файла:
  
```
>>> import io
>>> handle = io.StringIO("""Ignorance is the curse of God;
... knowledge is the wing wherewith we fly to heaven.""")
>>> words(handle)
['Ignorance', 'is', 'the', 'curse', 'of', 'God;\n', 'knowledge', 'is', 'the',
 'wing', 'wherewith', 'we', 'fly', 'to', 'heaven.']
```

Обратите внимание на то, что знаки препинания и символы переноса строки на конце
слов остаются без изменений: единственным разделителем слов считается единичный
пробел.

**b)** Напишите функцию `transition_matrix`, которая принимает список слов и возвращает
словарь. В этом словаре для каждой пары слов `(u, v)` содержится список из слов
`w`, которые встречаются во входном списке после последовательности слов `u v`.
В результате могут быть повторяющиеся слова, если какая-то тройка `u v w` 
встречается в исходном списке слов несколько раз.

Для примера выше:

```
>>> language = words(handle)
>>> m = transition_matrix(language)
>>> m["is", "the"]
['curse', 'wing']
```

**c)** Напишите функцию `markov_chain`, генерирующую предложения определённой
длины. Функция принимает три аргумента:
  - список слов, результат работы функции `words`,
  - словарь, построенный с помощью функции `transition_matrix`,
  - натуральное число -- количество слов в предложении, которое нужно
    сгенерировать.

Напомню, как генерировать случайные предложения. Будем порождать слова в
предложении слева направо одно за другим:

  - Случайно выберем первые два слова из всех слов `words`.
  - Каждое t-е слово будем порождать случайно при условии известных
    нам (t-2)-го и (t-1)-го слов (воспользуемся `transition_matrix`).
  - Если такая пара раньше не встречалась (в словаре `transition_matrix` её
    нет), то t-е слово берётся случайно из всех слов.
    
Вам пригодятся функции `choice` и `choices` из модуля `random`, ознакомьтесь
с их документацией самостоятельно. 

**d)** Напишите функцию `snoop_says`, которая принимает путь к файлу
`snoop279.txt` (файл состоит из сконкатенированных текстов Снуп Догга,
скачанных с сайта [AZLyrics](http://azlyrics.com/s/snoopdogg.html)) и
натуральное число -- длину предложения и возвращает случайное предложение
указанной длины на языке Снуп Догга.

```
>>> print(snoop_says("./snoop279.txt", 23))
 And check the file
 Under G you will see, that ever since Snoopy was a juvenile
 They cut me loose in nine-deuce swore
```
