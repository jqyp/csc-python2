# Задание 1 (4 балла)
  
Следующие задания нужно реализовать с помощью коллекций из модуля `collections`.

**a)** Реализуйте функцию `factor`, которая строит сжатое представление
последовательности с повторяющимися элементами. Результат вызова функции --
именованный кортеж `Factor` с двумя полями `elements` и `levels`, где `levels`
-- словарь, сопоставляющий каждому **уникальному** элементу входной
последовательности его номер, а `elements` -- последовательность, кодирующая
исходную при помощи номеров уникальных элементов.
  
```
>>> f = factor(["a", "a", "b"])
>>> f.elements
[0, 0, 1]
>>> f.levels["b"]
1
>>> list(f.levels.items())
[('a', 0), ('b', 1)]
>>> f = factor(["a", "b", "c", "b", "a"])
>>> f.elements
[0, 1, 2, 1, 0]
>>> list(f.levels.items())
[('a', 0), ('b', 1), ('c', 2)]
```

Номера уровней в возвращаемом кортеже должны соответствовать порядку уникальных
элементов во входном списке.

**b)** Реализуйте функцию `group_by`, группирующую переданную ей
последовательность объектов по функции-ключу. Результатом функции `group_by`
является словарь, в котором по ключу `k` содержится список объектов, на которых
функция-ключ вернула значение `k`.
  
```
>>> dict(group_by(["foo", "boo", "barbra"], len))
{3: ['foo', 'boo'], 6: ['barbra']}
```

**c)** Напишите функцию `invert`. Функция принимает словарь и возвращает новый
словарь, в котором для каждого значения из исходного словаря содержится
множество соответствующих ему ключей.
  
```
>>> dict(invert({"a": 42, "b": 42, "c": 24}))
{24: {'c'}, 42: {'b', 'a'}}
```

# Задание 2 (6 баллов)

Декоратор `functools.lru_cache` позволяет запомнить фиксированное количество
результатов последних вызовов функции. Префикс LRU (least recently used)
означает, что в случае переполнения кеша вытесняется элемент, обращение к
которому на чтение или запись максимально отдалено от текущего обращения. Такой
элемент всегда единственный.

Реализуйте декоратор `lru_cache`. Пример работы декоратора:

```
>>> @lru_cache
... def fib(n):
...     return n if n <= 1 else fib(n - 1) + fib(n - 2)
...
>>> fib(10)
55
```

Декоратор должен принимать один ключевой аргумент `maxsize` -- максимальное
количество элементов кеше, по умолчанию равный `64`.

Кроме того, к функции обёртке следует добавить два метода, `cache_info` и 
`clear_cache`.

Метод `cache_info` возвращает кортеж `CacheInfo` из четырёх элементов:
```
#                            максимальный размер
>>> fib.cache_info()  #         v
CacheInfo(hits=8, misses=11, maxsize=64, currsize=11)
#         ^            ^                     ^
#         |            |                текущий размер
#    попали в кеш   пересчитали значение
```

Метод `cache_clear` очищает кеш и сбрасывает счётчики:

```
>>> fib.cache_clear()
>>> fib.cache_info()
CacheInfo(hits=0, misses=0, maxsize=64, currsize=0)
```

# Задание 3 (6 балла)

Опечатки -- ежедневная проблема всех пользователей компьютера. Борьбе с
опечатками посвящено большое количество
[публикаций](http://scholar.google.com/scholar?q=spelling+correction).
Мы попробуем решить задачу исправления опечаток для списка слов.

**a)** Напишите функцию `build_graph`, которая по заданному списку слов `words` и
значению `mismatch_percent` строит неориентированный граф, называемый графом
Хемминга. Каждое слово из списка `words` это метка, соответствующей ему вершины
в графе. Ребро между двумя вершинами проводится, если:
  - длины строк, соответствующих вершинам, равны,
  - `d <= mismatch_percent * n / 100`, где `d` -- расстояние Хемминга между 
    двумя строками, а `n` -- их длина.

```
>>> words = ["hello", "helol", "ehllo", "tiger", "field"]
>>> g = build_graph(words, mismatch_percent=50.)
>>> g
{0: [1, 2], 1: [0], 2: [0], 3: [], 4: []}
```

Обратите внимание, что одинаковым словам в списке `words` соответствуют разные
вершины в итоговом графе.

**b)** Неориентированный граф в Python удобно представлять в виде словаря, ключи
которого -- вершины графа, а значения -- соответствующие списки смежности. Часто
вершины графа как-то занумерованы и представляются в виде чисел. Также у вершин
есть текстовые метки, которые хранятся в отдельном списке.

Напишите функцию `export_graph`, которая принимает граф и список меток для
каждой вершины графа и возвращает граф в формате
[DOT](https://en.wikipedia.org/wiki/DOT_(graph_description_language)). Формат
DOT по сути представляет из себя список ребер с метаданными.

Порядок следования строчек внутри оператора `graph` не важен.

Обратите внимание, что для каждой пары вершин из графа в DOT файле должно
остаться не более одного ребра. Направление ребра в файле значения не имеет, то
есть ребро `(0, 1)` можно записать либо как `0 -- 1`, либо как `1 -- 0`.

```
>>> g = {0: [1, 2], 1: [0], 2: [0]}
>>> labels = ["a", "b", "c"]
>>> print(export_graph(g, labels))
graph {
0 [label="a"]
0 -- 1
0 -- 2
1 [label="b"]
2 [label="c"]
}
```

Для визулизации DOT файлов можно воспользоваться сервисом 
[WebGraphviz](http://www.webgraphviz.com/).

**c)** Напишите функцию `find_connected_components`, которая по заданному
неориентированному графу строит список его компонент связности:
  
```
>>> g = {0: [1, 2], 1: [0], 2: [0], 3: [], 4: []}
>>> find_connected_components(g)
[{0, 1, 2}, {3}, {4}]
```

**d)** Напишите функцию `find_consensus`, которая принимает на вход список слов
одинаковой длины. Она возвращает строку, в которой i-й символ -- наиболее
часто встречающаяся буква, стоящая в i-й позиции, во всех словах из списка.
Найденная строка называется консенсусной. Если консенсусных строк несколько,
можно вернуть любую.
  
```
>>> find_consensus(["hello", "helol", "ehllo"])
'hello'
>>> find_consensus(["bug", "bow", "bag", "bar"])
'bag'
```

**e)** Напишите функцию `correct_typos`, которая
принимает на вход список слов и значение `mismatch_percent`
и возвращает новый список, где слова с опечатками исправлены.

Исправление слов происходит по следующему алгоритму.

  - Строим по списку слов граф Хемминга, используя переданное значение
  `mismatch_percent`.
  - Ищем в полученном графе компоненты связности.
  - Для каждой найденной компоненты связности строим консенсусную строку и
  исправляем с помощью неё все слова из этой компоненты. Исправить в данном
  случае означает заменить слово с опечаткой на соответствующую консенсусную
  строку.

```
>>> words = ["hello", "helol", "ehllo", "tiger", "field", "abracadabra"]
>>> correct_typos(words, mismatch_percent=50.)
['hello', 'hello', 'hello', 'tiger', 'field', 'abracadabra']
```